/**
 * 
 * Script applied to create and controle the globe animation using ThreeJs
 */

ORBITAL.Globe = function (e, o) {
  (self = self || {}),
    ((o = o || {}).scale = o.scale || 2),
    (o.worldImage = o.worldImage || "/images/world.jpg"),
    (self.hslList = [
      _.clone(new THREE.Color("#FF0900").getHSL()),
      _.clone(new THREE.Color("#FF632E").getHSL()),
      _.clone(new THREE.Color("#FFC62E").getHSL()),
      _.clone(new THREE.Color("#4BAD00").getHSL()),
      _.clone(new THREE.Color("#922EFF").getHSL()),
      _.clone(new THREE.Color("#2E9FFF").getHSL()),
    ]);
  var n,
    i,
    s,
    l,
    r,
    a,
    u,
    f,
    c = {
      earth: {
        uniforms: { texture: { type: "t", value: null } },
        vertexShader: [
          "varying vec3 vNormal;",
          "varying vec2 vUv;",
          "void main() {",
          "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
          "vNormal = normalize( normalMatrix * normal );",
          "vUv = uv;",
          "}",
        ].join("\n"),
        fragmentShader: [
          "uniform sampler2D texture;",
          "varying vec3 vNormal;",
          "varying vec2 vUv;",
          "void main() {",
          "vec3 diffuse = texture2D( texture, vUv ).xyz;",
          "float intensity = 1.05 - dot( vNormal, vec3( 0.0, 0.0, 1.0 ) );",
          "vec3 atmosphere = vec3( 1.0, 1.0, 1.0 ) * pow( intensity, 3.0 );",
          "gl_FragColor = vec4( diffuse + atmosphere, 1.0 );",
          "}",
        ].join("\n"),
      },
      atmosphere: {
        uniforms: {},
        vertexShader: [
          "varying vec3 vNormal;",
          "void main() {",
          "vNormal = normalize( normalMatrix * normal );",
          "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
          "}",
        ].join("\n"),
        fragmentShader: [
          "varying vec3 vNormal;",
          "void main() {",
          "float intensity = pow( 0.75 - dot( vNormal, vec3( 0, 0, 1.0 ) ), 12.0 );",
          "gl_FragColor = vec4( 0.784,0.784,0.784,1.0 ) * intensity;",
          "}",
        ].join("\n"),
      },
    };
  (self.pointCache = []), (self.focusPoints = []), (self.earth = null);
  var m = { x: 0, y: 0 },
    d = { x: 0, y: 0 },
    v = { x: 0, y: 0 },
    h = { x: (3 * Math.PI) / 2, y: Math.PI / 6 },
    y = { x: 0, y: 0 },
    w = 1e5,
    p = 1e5,
    E = Math.PI / 2;

    /**
     * Initialization of the globe animation
     */
  (init = function () {
    var t, m, d, v;
    (l = e.offsetWidth || window.innerWidth*2.1),
      (r = e.offsetHeight || 928.2),
      ((n = new THREE.PerspectiveCamera(30, l / r, 1, 1e4)).position.z = w),
      (a = new THREE.Vector3()),
      (self.scene = new THREE.Scene()),
      (i = new THREE.Scene()),
      (v = new THREE.SphereGeometry(200, 40, 30)),
      (t = c.earth),
      ((m = THREE.UniformsUtils.clone(t.uniforms)).texture.value =
        THREE.ImageUtils.loadTexture("" + o.worldImage)),
      (d = new THREE.ShaderMaterial({
        uniforms: m,
        vertexShader: t.vertexShader,
        fragmentShader: t.fragmentShader,
      })),
      (self.earth = new THREE.Mesh(v, d)),
      (self.earth._type = "earth"),
      (self.earth.rotation.y = Math.PI),
      self.scene.add(self.earth),
      (t = c.atmosphere),
      (m = THREE.UniformsUtils.clone(t.uniforms)),
      (d = new THREE.ShaderMaterial({
        uniforms: m,
        vertexShader: t.vertexShader,
        fragmentShader: t.fragmentShader,
        side: THREE.BackSide,
      })),
      ((u = new THREE.Mesh(v, d)).scale.x = u.scale.y = u.scale.z = 1.1),
      i.add(u),
      ((s = new THREE.WebGLRenderer({ antialias: !0 })).autoClear = !1),
      s.setClearColorHex(0, 0),
      s.setSize(l, r),
      (s.domElement.style.position = "absolute"),
      e.append(s.domElement),
      $(window).on("resize", onWindowResize),
      e.on("mousewheel", onMouseWheel);
  }),

  /**
   * Data and points handling
   */
    (self.addData = function (e) {
      _.each(_.values(e), function (e) {
        addPoint(e.lat, e.lng, e.mag || e.Sessions);
      });
    }),
    (self.getPoint = function (e, o) {
      var n = self.llkey(e, o);
      if (n in self.pointCache) return self.pointCache[n];
    }),
    (self.addPoint = function (e, n, t) {
      t *= 0.001;
      var i = self.llround(e, n),
        s = self.llkey(i.lat, i.lng),
        l = null;
      s in self.pointCache
        ? (l = self.pointCache[s]).setMag(t)
        : ((l = new ORBITAL.Point(i.lat, i.lng, t, u, self.scene, o)),
          (self.pointCache[s] = l)),
        l.update({
          flash: !0,
          flashOver: !1,
          flashDuration: 300,
          flashHSLList: self.hslList,
        });
    }),
    (self.roundPoint = function (e) {
      return ORBITAL.GeoUtil.roundPoint(e, o.scale);
    }),
    (self.llround = function (e, o) {
      return { lat: self.roundPoint(e), lng: self.roundPoint(o) };
    }),
    (self.llkey = function (e, o) {
      return (ll = self.llround(e, o)), ORBITAL.GeoUtil.llkey(ll.lat, ll.lng);
    });
  var M = new THREE.Projector();

  /**
   * Mouse events & Events listeners applied to the globe
   */

  return (
    (self.onMouseMoveWithMouseUp = function (e) {
      e.preventDefault();
      var o = (e.clientX / window.innerWidth) * 2 - 1,
        t = (-e.clientY / window.innerHeight) * 2 + 1,
        i = new THREE.Vector3(o, t, 0.5);
      M.unprojectVector(i, n);
      var s = new THREE.Raycaster(
        n.position,
        i.sub(n.position).normalize()
      ).intersectObjects(self.scene.children);
      s.length > 0 &&
        _.each(s, function (e) {
          if ("point" == e.object.type) {
            var o = e.object.geometry,
              n = ORBITAL.Util.colorFnRand();
            ORBITAL.PointUtil.setPointColor(e.object, n),
              (o.colorsNeedUpdate = !0);
          }
        });
    }),
    (self.onMouseMoveWithMouseDown = function (e) {
      (m.x = -e.clientX), (m.y = e.clientY);
      var o = w / 1e3;
      (h.x = y.x + 0.005 * (m.x - d.x) * o),
        (h.y = y.y + 0.005 * (m.y - d.y) * o),
        (h.y = h.y > E ? E : h.y),
        (h.y = h.y < -E ? -E : h.y);
    }),
    (self.onMouseUp = function (o) {
      e.off("mousemove", onMouseMoveWithMouseDown),
        e.off("mouseup", onMouseUp),
        e.off("mouseout", onMouseOut),
        e.attr("style", "cursor: auto");
    }),
    (self.onMouseWheel = function (e) {
      return (
        e.preventDefault(), f && zoom(0.3 * e.originalEvent.wheelDeltaY), !1
      );
    }),

    
    /**
     * On Window redize event
     */
    (self.onWindowResize = function (e) {
      (n.aspect = window.innerWidth*2.1 / 928.2),
        n.updateProjectionMatrix()
        s.setSize(window.innerWidth*2.1 , 928.2);
    }),
    (self.zoom = function (e) {
      p = (p = (p -= e) > 1e3 ? 1e3 : p) < 350 ? 350 : p;
    }),
    (self.animate = function () {
      setTimeout( function() {

        requestAnimationFrame( animate );

    }, 1000 / 30 ), render();
    }),
    (self.focusRotate = function () {
      void 0 !== self.focusPoints &&
        self.focusPoints.length > 0 &&
        ((t = self.focusPoints[0]),
        (xyz = ORBITAL.GeoUtil.xyzFromGeo(t.lat, t.lng)),
        self.glide(xyz.x, xyz.y),
        self.focusPoints.push(self.focusPoints.shift()),
        _.delay(focusRotate, 1e3 * t.duration));
    }),
    (self.addFocusPoint = function (e, o, n, t) {
      self.focusPoints || (self.focusPoints = []);
      var i = ORBITAL.GeoUtil.xyzFromGeo(o, n);
      self.focusPoints.push({ name: e, x: i.x, y: i.y, z: i.z, duration: t });
    }),
    (self.setFocus = function (e, o, n) {
      (n = n || {}),
        (t = ORBITAL.GeoUtil.xyzFromGeo(e, o)),
        self.glide(t.x, t.y),
        n.hilight && self.pointCache[self.llkey(e, o)];
    }),

    /**
     * Render the Globe
     */
    (self.glide = _.throttle(function (e, o, n) {
      n = n || 1e3;
      var i = w / 1e3;
      (t = { x: 0.005 * e * i, y: 0.005 * o * i }),
        (t.y = h.y > E ? E : h.y),
        (t.y = h.y < -E ? -E : h.y),
        new TWEEN.Tween(h).to(t, n).start();
    }, 1e3)),
    (self.render = function () {
      zoom(0),
        TWEEN.update(),
        (h.x += -0.001),
        (v.x += 0.1 * (h.x - v.x)),
        (v.y += 0.1 * (h.y - v.y)),
        (w += 0.3 * (p - w)),
        (n.position.x = w * Math.sin(v.x) * Math.cos(v.y)),
        (n.position.y = w * Math.sin(v.y)),
        (n.position.z = w * Math.cos(v.x) * Math.cos(v.y)),
        n.lookAt(self.scene.position),
        a.copy(n.position),
        s.clear(),
        s.render(self.scene, n),
        s.render(i, n);
    }),
    init(),
    self
  );
};
